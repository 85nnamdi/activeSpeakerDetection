from math import*
from time import perf_counter

def euclidean_distance(x,y):
    val =[]
    try:
        for (j,k) in zip(x,y):
            val.append(sqrt( sum(pow(a-b,2) for a, b in zip(j, k) if a!=0 if b!=0) ))
        return val
        # [[a  for a in (i,j)] for (i,j) in zip(x,y) ] a =if a !=0 if b !=0
    except TypeError:
        try:
            return sqrt( sum(pow(a-b,2) for a, b in zip(x, y) if a!=0 if b!=0) )  
        except TypeError:
            return sqrt( pow(x-y,2) )
        
x = [31.2745, 68.6238, 4.51401, 123.9, 0, 0, 0, 0, 0, 0, 45.9428, 130.342, 84.8854, 227.69, 71.9085, 198.462, 15.103, 55.6731, 36.2342, 54.0467, 4.53612, 62.1578, 47.6126, 58.8483]
y = [32.0425, 71.7564, 4.59401, 128.127, 0, 0, 0, 0, 0, 0, 48.58, 138.004, 88.3041, 230.793, 58.5423, 166.253, 18.7514, 58.5472, 41.9491, 58.5437, 4.61794, 68.4331, 0, 0]
yy = [  [0, 0, 33.9384, 52.0067, 31.4057, 52.5132, 37.9907, 58.3384, 31.9122, 52.5132, 32.4188, 53.5263, 31.1524, 52.2599, 36.7244, 55.5524, 38.4972, 54.2861, 39.5103, 54.2861, 40.7767, 55.2992, 39.2571, 55.0459, 38.244, 55.0459, 39.0038, 54.5394, 16.716, 84.6785, 37.4842, 84.4252, 18.7422, 84.9318, 26.3403, 84.4252, 29.1263, 84.172, 32.1655, 82.9056, 35.7113, 84.172, 32.1655, 86.1981, 28.873, 86.9579, 26.087, 86.7047], 
        [33.6851, -14.3724, 0, -31.3199, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 52.5975, -10.1355, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.3199, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 48.6865, -14.3724, 145.809, -31.6458, 48.6865, -14.3724, 48.6865, -14.3724, 48.6865, -14.3724, 145.809, -31.6458, 48.6865, -14.3724, 52.5975, -10.1355, 48.6865, -14.3724, 13.6865, -14.3724],
        [33.6851, -14.3724, 145.809, 0, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 52.5975, -10.1355, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.3199, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 48.6865, -14.3724, 145.809, -31.6458, 48.6865, -14.3724, 48.6865, -14.3724, 48.6865, -14.3724, 145.809, -31.6458, 48.6865, -14.3724, 52.5975, -10.1355, 48.6865, -14.3724, 45.6865, 54.3724], 
        ]
zz = [
        [0, -14.3724, 33.9384, 52.0067, 31.4057, 52.5132, 37.9907, 58.3384, 31.9122, 52.5132, 32.4188, 53.5263, 31.1524, 52.2599, 36.7244, 55.5524, 38.4972, 54.2861, 39.5103, 54.2861, 40.7767, 55.2992, 39.2571, 55.0459, 38.244, 55.0459, 39.0038, 54.5394, 16.716, 84.6785, 37.4842, 84.4252, 18.7422, 84.9318, 26.3403, 84.4252, 29.1263, 84.172, 32.1655, 82.9056, 35.7113, 84.172, 32.1655, 86.1981, 28.873, 86.9579, 26.087, 86.7047], 
        [0, 0, 145.809, -31.3199, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 52.5975, -10.1355, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.3199, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 48.6865, -14.3724, 145.809, -31.6458, 48.6865, -14.3724, 48.6865, -14.3724, 48.6865, -14.3724, 145.809, -31.6458, 48.6865, -14.3724, 52.5975, -10.1355, 48.6865, 54.3724, 23.6865, 0.3724],
        [33.6851, -14.3724, 0, -31.3199, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 52.5975, -10.1355, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.3199, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 145.483, -31.6458, 48.6865, -14.3724, 145.809, -31.6458, 48.6865, -14.3724, 48.6865, -14.3724, 48.6865, -14.3724, 145.809, -31.6458, 48.6865, -14.3724, 52.5975, -10.1355, 48.6865, 14.3724, 32.6865, 99.3724] 
        ]

def calculate_distance():
    # #Keypoint 1 0r 8 is [0,0]
    # 1. normalizion we are using the x and y in a single vector.
    normalization_value = euclidean_distance(x[2:4], x[16:18])
    
    # 2. get the crop of the target person based on the coordinates from the CSV and the keypoints
    width, height = 854, 480 # read from the coresponding frame for each video
    x1,y1, x2, y2 = 0.366197 *width,	0.147917*height,	0.711268 *width,	0.860417*height

    faceCoords = [0, 15, 16, 17, 18]
    POSECOORDS = [0,1,2,3,4,5,6,7,8,15,16,17,18]
    poses = [
        [310.409, 250.138, 219.938, 318.628, 156.838, 318.576, 151.39, 450.313, 274.76, 357.106, 285.718, 318.619, 0, 0, 0, 0, 0, 0, 283.062, 228.233, 318.542, 231.029, 228.188, 233.742, 0, 0], 
        [475.05, 170.506, 614.854, 258.307, 713.624, 263.826, 0, 0, 0, 0, 516.178, 252.849, 472.31, 475.02, 0, 0, 0, 0, 0, 0, 485.99, 143.254, 0, 0, 538.205, 143.136]]
    for p in poses:
        newListx = []
        newListy = []
        for face in faceCoords:
            newListx.append(p[POSECOORDS.index(face)*2])
            newListy.append(p[POSECOORDS.index(face)*2+1])

        for posX in newListx:
            if posX ==0:
                continue
            if posX < x1 or posX > x2:
                break
        else:
            for posY in newListy:
                if posY ==0:
                    continue
                if posY < y1 or posY > y2:
                    break
            else:
                # for iterx,itery in newListx,newListx:
                #     print(f'Person with pose {(newListx[newListx.index(iterx)], newListy[newListy.index(itery)])}')
                # print('')
                print([qt for qt in zip(newListx, newListy)])
                # print(f'Person with pose {(newListx[newListx.index(0)], newListy[2])}')                         
    # print([ (m-n)/normalization_value for n,m in zip(yy, zz) if x !=0 if y !=0])

if __name__ == '__main__':
    start = perf_counter()
    calculate_distance()
    end = perf_counter()
    print ('Total processing time : ',end - start)
calculate_distance()
# store the len(x) to know the num of cordinate we're working with.